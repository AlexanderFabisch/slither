<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title></title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.2/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.0.2/dist/leaflet.js"></script>
    <style>
        #mapdiv {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;

            transition: height 0.5s ease-in-out;
        }
    </style>
</head>
<body>

<div id="mapdiv"></div>
<!-- Map rendered with Leaflet http://leafletjs.com/ and OpenStreetMap -->
<script>
// Leaflet.MultiOptionsPolyline: https://github.com/hgoebl/Leaflet.MultiOptionsPolyline
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define(["leaflet"], factory);
    } else if (typeof module === "object" && module.exports) {
        factory(require("leaflet"));
    } else {
        factory(root.L);
    }
} (this, function (L) {
    "use strict";

/*
 * L.MultiOptionsPolyline is a MultiPolyLine which parts can be styled differently.
 * options: {
 *     multiOptions: {
 *         optionIdxFn: function (latLng, prevLatLng, index, allLatlngs),
 *         fnContext: ctx, // the context to call optionIdxFn (optional)
 *         options: [{}, {}, {}] or function, // options for the index returned by optionIdxFn. If supplied with a function then it will be called with the index
 *         copyBaseOptions: true
 *     },
 *     // other options from Polyline
 * }
 */
var MultiOptionsPolyline = L.FeatureGroup.extend({

    initialize: function (latlngs, options) {
        var copyBaseOptions = options.multiOptions.copyBaseOptions;

        this._layers = {};
        this._options = options;
        if (copyBaseOptions === undefined || copyBaseOptions) {
            this._copyBaseOptions();
        }

        this.setLatLngs(latlngs);
    },

    _copyBaseOptions: function () {
        var multiOptions = this._options.multiOptions,
            baseOptions,
            optionsArray = multiOptions.options,
            i, len = optionsArray.length;

        baseOptions = L.extend({}, this._options);
        delete baseOptions.multiOptions;

        for (i = 0; i < len; ++i) {
            optionsArray[i] = L.extend({}, baseOptions, optionsArray[i]);
        }
    },

    setLatLngs: function (latlngs) {
        var i, len = latlngs.length,
            multiOptions = this._options.multiOptions,
            optionIdxFn = multiOptions.optionIdxFn,
            fnContext = multiOptions.fnContext || this,
            prevOptionIdx, optionIdx,
            segmentLatlngs;

        this._originalLatlngs = latlngs;

        this.eachLayer(function (layer) {
            this.removeLayer(layer);
        }, this);

        for (i = 1; i < len; ++i) {
            optionIdx = optionIdxFn.call(
                fnContext, latlngs[i], latlngs[i - 1], i, latlngs);

            if (i === 1) {
                segmentLatlngs = [latlngs[0]];
                prevOptionIdx = optionIdxFn.call(fnContext, latlngs[0], latlngs[0], 0, latlngs);
            }

            segmentLatlngs.push(latlngs[i]);

            // is there a change in options or is it the last point?
            if (prevOptionIdx !== optionIdx || i === len - 1) {
                // Check if options is a function or an array
                if (typeof multiOptions.options === "function") {
                    this.addLayer(L.polyline(segmentLatlngs, multiOptions.options(prevOptionIdx)));
                } else {
                    this.addLayer(L.polyline(segmentLatlngs, multiOptions.options[prevOptionIdx]));
                }

                prevOptionIdx = optionIdx;
                segmentLatlngs = [latlngs[i]];
            }
        }

        return this;
    },

    getLatLngs: function () {
        return this._originalLatlngs;
    },

    getLatLngsSegments: function () {
        var latlngs = [];

        this.eachLayer(function (layer) {
            latlngs.push(layer.getLatLngs());
        });

        return latlngs;
    }
});

L.MultiOptionsPolyline = MultiOptionsPolyline;
L.multiOptionsPolyline = function (latlngs, options) {
    return new MultiOptionsPolyline(latlngs, options);
};

}));


var map = L.map('mapdiv');
L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19
}).addTo(map);
var latlngs = [
{% for lat, lon in coords %}
    {{ "{" }} "lat": {{ lat }}, "lng": {{ lon }}, "vel": {{ velocities[loop.index0] }} {{ "}" }},
{% endfor %}
];

var path = L.multiOptionsPolyline(latlngs, {
    multiOptions: {
        optionIdxFn: function (latLng) {
            var i, velThresholds = {{ velocity_thresholds }};

            for (i = 0; i < velThresholds.length; ++i) {
                if (latLng.vel <= velThresholds[i]) {
                    return i;
                }
            }
            return velThresholds.length;
        },
        options: [
{% for c in colors %}
            {color: '{{ c }}'},
{% endfor %}
        ]
    },
    weight: 5,
    lineCap: 'butt',
    opacity: 0.75,
    smoothFactor: 1}
).addTo(map);

L.marker([{{ coords[0, 0] }}, {{ coords[0, 1] }}]).addTo(map).bindPopup("start");
L.marker([{{ coords[-1, 0] }}, {{ coords[-1, 1] }}]).addTo(map).bindPopup("finish");
{% for label, marker in distance_markers.items() %}
    L.marker([{{ coords[marker, 0] }}, {{ coords[marker, 1] }}]).addTo(map).bindPopup("{{ label }}");
{% endfor %}
map.fitBounds(path.getBounds());

$mapdiv.on('map-container-resize', function () {
   setTimeout(function(){ map.invalidateSize()}, 400);
});
</script>

</body>
</html>
